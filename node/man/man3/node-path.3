.\" Generated with Ronnjs/v0.1
.\" http://github.com/kapouer/ronnjs/
.
.TH "NODE\-PATH" "3" "October 2011" "" ""
.
.SH "NAME"
\fBnode-path\fR \-\- http://nodejs\.org/docs/v0\.4\.8/api/path\.html
.
.SH "Path"
This module contains utilities for dealing with file paths\.  Use \fBrequire(\'path\')\fR to use it\.  It provides the following methods:
.
.SS "path\.normalize(p)"
Normalize a string path, taking care of \fB\'\.\.\'\fR and \fB\'\.\'\fR parts\.
.
.P
When multiple slashes are found, they\'re replaces by a single one;
when the path contains a trailing slash, it is preserved\.
On windows backslashes are used\. 
.
.P
Example:
.
.IP "" 4
.
.nf
path\.normalize(\'/foo/bar//baz/asdf/quux/\.\.\')
// returns
\'/foo/bar/baz/asdf\'
.
.fi
.
.IP "" 0
.
.SS "path\.join([path1], [path2], [\.\.\.])"
Join all arguments together and normalize the resulting path\.
Non\-string arguments are ignored\.
.
.P
Example:
.
.IP "" 4
.
.nf
path\.join(\'/foo\', \'bar\', \'baz/asdf\', \'quux\', \'\.\.\')
// returns
\'/foo/bar/baz/asdf\'
path\.join(\'foo\', {}, \'bar\')
// returns
\'foo/bar\'
.
.fi
.
.IP "" 0
.
.SS "path\.resolve([from \.\.\.], to)"
Resolves \fBto\fR to an absolute path\.
.
.P
If \fBto\fR isn\'t already absolute \fBfrom\fR arguments are prepended in right to left
order, until an absolute path is found\. If after using all \fBfrom\fR paths still
no absolute path is found, the current working directory is used as well\. The
resulting path is normalized, and trailing slashes are removed unless the path 
gets resolved to the root directory\. Non\-string arguments are ignored\.
.
.P
Another way to think of it is as a sequence of \fBcd\fR commands in a shell\.
.
.IP "" 4
.
.nf
path\.resolve(\'foo/bar\', \'/tmp/file/\', \'\.\.\', \'a/\.\./subfile\')
.
.fi
.
.IP "" 0
.
.P
Is similar to:
.
.IP "" 4
.
.nf
cd foo/bar
cd /tmp/file/
cd \.\.
cd a/\.\./subfile
pwd
.
.fi
.
.IP "" 0
.
.P
The difference is that the different paths don\'t need to exist and may also be
files\.
.
.P
Examples:
.
.IP "" 4
.
.nf
path\.resolve(\'/foo/bar\', \'\./baz\')
// returns
\'/foo/bar/baz\'
path\.resolve(\'/foo/bar\', \'/tmp/file/\')
// returns
\'/tmp/file\'
path\.resolve(\'wwwroot\', \'static_files/png/\', \'\.\./gif/image\.gif\')
// if currently in /home/myself/node, it returns
\'/home/myself/node/wwwroot/static_files/gif/image\.gif\'
.
.fi
.
.IP "" 0
.
.SS "path\.relative(from, to)"
Solve the relative path from \fBfrom\fR to \fBto\fR\|\.
.
.P
Sometimes we\'ve got two absolute pathes, and we need to calculate the relative path from one to another\.
It\'s accually the reverse transform of path\.resolve, which means we assume:
.
.IP "" 4
.
.nf
path\.resolve(from, path\.relative(from, to)) == path\.resolve(to)
.
.fi
.
.IP "" 0
.
.P
Examples:
.
.IP "" 4
.
.nf
path\.relative(\'C:\\\\orandea\\\\test\\\\aaa\', \'C:\\\\orandea\\\\impl\\\\bbb\')
// returns
\'\.\.\\\\\.\.\\\\impl\\\\bbb\'
path\.relative(\'/data/orandea/test/aaa\', \'/data/orandea/impl/bbb\')
// returns
\'\.\./\.\./impl/bbb\'
.
.fi
.
.IP "" 0
.
.SS "path\.dirname(p)"
Return the directory name of a path\.  Similar to the Unix \fBdirname\fR command\.
.
.P
Example:
.
.IP "" 4
.
.nf
path\.dirname(\'/foo/bar/baz/asdf/quux\')
// returns
\'/foo/bar/baz/asdf\'
.
.fi
.
.IP "" 0
.
.SS "path\.basename(p, [ext])"
Return the last portion of a path\.  Similar to the Unix \fBbasename\fR command\.
.
.P
Example:
.
.IP "" 4
.
.nf
path\.basename(\'/foo/bar/baz/asdf/quux\.html\')
// returns
\'quux\.html\'
path\.basename(\'/foo/bar/baz/asdf/quux\.html\', \'\.html\')
// returns
\'quux\'
.
.fi
.
.IP "" 0
.
.SS "path\.extname(p)"
Return the extension of the path\.  Everything after the last \'\.\' in the last portion
of the path\.  If there is no \'\.\' in the last portion of the path or the only \'\.\' is
the first character, then it returns an empty string\.  Examples:
.
.IP "" 4
.
.nf
path\.extname(\'index\.html\')
// returns
\'\.html\'
path\.extname(\'index\')
// returns
\'\'
.
.fi
.
.IP "" 0
.
.SS "path\.exists(p, [callback])"
Test whether or not the given path exists\.  Then, call the \fBcallback\fR argument
with either true or false\. Example:
.
.IP "" 4
.
.nf
path\.exists(\'/etc/passwd\', function (exists) {
  util\.debug(exists ? "it\'s there" : "no passwd!");
});
.
.fi
.
.IP "" 0
.
.SS "path\.existsSync(p)"
Synchronous version of \fBpath\.exists\fR\|\.