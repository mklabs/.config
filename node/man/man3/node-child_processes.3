.\" Generated with Ronnjs/v0.1
.\" http://github.com/kapouer/ronnjs/
.
.TH "NODE\-CHILD_PROCESSES" "3" "October 2011" "" ""
.
.SH "NAME"
\fBnode-child_processes\fR \-\- http://nodejs\.org/docs/v0\.4\.8/api/child_processes\.html
.
.SH "Child Processes"
Node provides a tri\-directional \fBpopen(3)\fR facility through the \fBChildProcess\fR
class\.
.
.P
It is possible to stream data through the child\'s \fBstdin\fR, \fBstdout\fR, and \fBstderr\fR in a fully non\-blocking way\.
.
.P
To create a child process use \fBrequire(\'child_process\')\.spawn()\fR\|\.
.
.P
Child processes always have three streams associated with them\. \fBchild\.stdin\fR, \fBchild\.stdout\fR, and \fBchild\.stderr\fR\|\.
.
.P
\fBChildProcess\fR is an \fBEventEmitter\fR\|\.
.
.SS "Event:  \'exit\'"
\fBfunction (code, signal) {}\fR
.
.P
This event is emitted after the child process ends\. If the process terminated
normally, \fBcode\fR is the final exit code of the process, otherwise \fBnull\fR\|\. If
the process terminated due to receipt of a signal, \fBsignal\fR is the string name
of the signal, otherwise \fBnull\fR\|\.
.
.P
See \fBwaitpid(2)\fR\|\.
.
.SS "child\.stdin"
A \fBWritable Stream\fR that represents the child process\'s \fBstdin\fR\|\.
Closing this stream via \fBend()\fR often causes the child process to terminate\.
.
.SS "child\.stdout"
A \fBReadable Stream\fR that represents the child process\'s \fBstdout\fR\|\.
.
.SS "child\.stderr"
A \fBReadable Stream\fR that represents the child process\'s \fBstderr\fR\|\.
.
.SS "child\.pid"
The PID of the child process\.
.
.P
Example:
.
.IP "" 4
.
.nf
var spawn = require(\'child_process\')\.spawn,
    grep  = spawn(\'grep\', [\'ssh\']);
console\.log(\'Spawned child pid: \' + grep\.pid);
grep\.stdin\.end();
.
.fi
.
.IP "" 0
.
.SS "child_process\.spawn(command, args=[], [options])"
Launches a new process with the given \fBcommand\fR, with  command line arguments in \fBargs\fR\|\.
If omitted, \fBargs\fR defaults to an empty Array\.
.
.P
The third argument is used to specify additional options, which defaults to:
.
.IP "" 4
.
.nf
{ cwd: undefined,
  env: process\.env,
  customFds: [\-1, \-1, \-1],
  setsid: false
}
.
.fi
.
.IP "" 0
.
.P
\fBcwd\fR allows you to specify the working directory from which the process is spawned\.
Use \fBenv\fR to specify environment variables that will be visible to the new process\.
With \fBcustomFds\fR it is possible to hook up the new process\' [stdin, stdout, stderr] to
existing streams; \fB\-1\fR means that a new stream should be created\. \fBsetsid\fR,
if set true, will cause the subprocess to be run in a new session\.
.
.P
Example of running \fBls \-lh /usr\fR, capturing \fBstdout\fR, \fBstderr\fR, and the exit code:
.
.IP "" 4
.
.nf
var util  = require(\'util\'),
    spawn = require(\'child_process\')\.spawn,
    ls    = spawn(\'ls\', [\'\-lh\', \'/usr\']);
ls\.stdout\.on(\'data\', function (data) {
  console\.log(\'stdout: \' + data);
});
ls\.stderr\.on(\'data\', function (data) {
  console\.log(\'stderr: \' + data);
});
ls\.on(\'exit\', function (code) {
  console\.log(\'child process exited with code \' + code);
});
.
.fi
.
.IP "" 0
.
.P
Example: A very elaborate way to run \'ps ax | grep ssh\'
.
.IP "" 4
.
.nf
var util  = require(\'util\'),
    spawn = require(\'child_process\')\.spawn,
    ps    = spawn(\'ps\', [\'ax\']),
    grep  = spawn(\'grep\', [\'ssh\']);
ps\.stdout\.on(\'data\', function (data) {
  grep\.stdin\.write(data);
});
ps\.stderr\.on(\'data\', function (data) {
  console\.log(\'ps stderr: \' + data);
});
ps\.on(\'exit\', function (code) {
  if (code !== 0) {
    console\.log(\'ps process exited with code \' + code);
  }
  grep\.stdin\.end();
});
grep\.stdout\.on(\'data\', function (data) {
  console\.log(data);
});
grep\.stderr\.on(\'data\', function (data) {
  console\.log(\'grep stderr: \' + data);
});
grep\.on(\'exit\', function (code) {
  if (code !== 0) {
    console\.log(\'grep process exited with code \' + code);
  }
});
.
.fi
.
.IP "" 0
.
.P
Example of checking for failed exec:
.
.IP "" 4
.
.nf
var spawn = require(\'child_process\')\.spawn,
    child = spawn(\'bad_command\');
child\.stderr\.setEncoding(\'utf8\');
child\.stderr\.on(\'data\', function (data) {
  if (/^execvp\\(\\)/\.test(data)) {
    console\.log(\'Failed to start child process\.\');
  }
});
.
.fi
.
.IP "" 0
.
.P
See also: \fBchild_process\.exec()\fR
.
.SS "child_process\.exec(command, [options], callback)"
High\-level way to execute a command as a child process, buffer the
output, and return it all in a callback\.
.
.IP "" 4
.
.nf
var util = require(\'util\'),
    exec = require(\'child_process\')\.exec,
    child;
child = exec(\'cat *\.js bad_file | wc \-l\',
  function (error, stdout, stderr) {
    console\.log(\'stdout: \' + stdout);
    console\.log(\'stderr: \' + stderr);
    if (error !== null) {
      console\.log(\'exec error: \' + error);
    }
});
.
.fi
.
.IP "" 0
.
.P
The callback gets the arguments \fB(error, stdout, stderr)\fR\|\. On success, \fBerror\fR
will be \fBnull\fR\|\.  On error, \fBerror\fR will be an instance of \fBError\fR and \fBerr\.code\fR
will be the exit code of the child process, and \fBerr\.signal\fR will be set to the
signal that terminated the process\.
.
.P
There is a second optional argument to specify several options\. The default options are
.
.IP "" 4
.
.nf
{ encoding: \'utf8\',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: \'SIGTERM\',
  cwd: null,
  env: null }
.
.fi
.
.IP "" 0
.
.P
If \fBtimeout\fR is greater than 0, then it will kill the child process
if it runs longer than \fBtimeout\fR milliseconds\. The child process is killed with \fBkillSignal\fR (default: \fB\'SIGTERM\'\fR)\. \fBmaxBuffer\fR specifies the largest
amount of data allowed on stdout or stderr \- if this value is exceeded then
the child process is killed\.
.
.SS "child_process\.fork(modulePath, arguments, options)"
This is a special case of the \fBspawn()\fR functionality for spawning Node
processes\. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built\-in\. The
channel is written to with \fBchild\.send(message)\fR and messages are recieved
by a \fB\'message\'\fR event on the child\.
.
.P
For example:
.
.IP "" 4
.
.nf
var cp = require(\'child_process\');
var n = cp\.fork(__dirname + \'/sub\.js\');
n\.on(\'message\', function(m) {
  console\.log(\'PARENT got message:\', m);
});
n\.send({ hello: \'world\' });
.
.fi
.
.IP "" 0
.
.P
And then the child script, \fB\'sub\.js\'\fR would might look like this:
.
.IP "" 4
.
.nf
process\.on(\'message\', function(m) {
  console\.log(\'CHILD got message:\', m);
});
process\.send({ foo: \'bar\' });
.
.fi
.
.IP "" 0
.
.P
In the child the \fBprocess\fR object will have a \fBsend()\fR method, and \fBprocess\fR
will emit objects each time it receives a message on its channel\.
.
.P
By default the spawned Node process will have the stdin, stdout, stderr
associated with the parent\'s\. This can be overridden by using the \fBcustomFds\fR option\.
.
.P
These child Nodes are still whole new instances of V8\. Assume at least 30ms
startup and 10mb memory for each new Node\. That is, you cannot create many
thousands of them\.
.
.SS "child\.kill(signal=\'SIGTERM\')"
Send a signal to the child process\. If no argument is given, the process will
be sent \fB\'SIGTERM\'\fR\|\. See \fBsignal(7)\fR for a list of available signals\.
.
.IP "" 4
.
.nf
var spawn = require(\'child_process\')\.spawn,
    grep  = spawn(\'grep\', [\'ssh\']);
grep\.on(\'exit\', function (code, signal) {
  console\.log(\'child process terminated due to receipt of signal \'+signal);
});
// send SIGHUP to process
grep\.kill(\'SIGHUP\');
.
.fi
.
.IP "" 0
.
.P
Note that while the function is called \fBkill\fR, the signal delivered to the child
process may not actually kill it\.  \fBkill\fR really just sends a signal to a process\.
.
.P
See \fBkill(2)\fR