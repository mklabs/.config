.\" Generated with Ronnjs/v0.1
.\" http://github.com/kapouer/ronnjs/
.
.TH "NODE\-DGRAM" "3" "October 2011" "" ""
.
.SH "NAME"
\fBnode-dgram\fR \-\- http://nodejs\.org/docs/v0\.4\.8/api/dgram\.html
.
.SH "UDP / Datagram Sockets"
Datagram sockets are available through \fBrequire(\'dgram\')\fR\|\.  Datagrams are most commonly
handled as IP/UDP messages but they can also be used over Unix domain sockets\.
.
.SS "Event: \'message\'"
\fBfunction (msg, rinfo) { }\fR
.
.P
Emitted when a new datagram is available on a socket\.  \fBmsg\fR is a \fBBuffer\fR and \fBrinfo\fR is
an object with the sender\'s address information and the number of bytes in the datagram\.
.
.SS "Event: \'listening\'"
\fBfunction () { }\fR
.
.P
Emitted when a socket starts listening for datagrams\.  This happens as soon as UDP sockets
are created\.  Unix domain sockets do not start listening until calling \fBbind()\fR on them\.
.
.SS "Event: \'close\'"
\fBfunction () { }\fR
.
.P
Emitted when a socket is closed with \fBclose()\fR\|\.  No new \fBmessage\fR events will be emitted
on this socket\.
.
.SS "dgram\.createSocket(type, [callback])"
Creates a datagram socket of the specified types\.  Valid types are: \fBudp4\fR, \fBudp6\fR, and \fBunix_dgram\fR\|\.
.
.P
Takes an optional callback which is added as a listener for \fBmessage\fR events\.
.
.SS "dgram\.send(buf, offset, length, path, [callback])"
For Unix domain datagram sockets, the destination address is a pathname in the filesystem\.
An optional callback may be supplied that is invoked after the \fBsendto\fR call is completed
by the OS\.  It is not safe to re\-use \fBbuf\fR until the callback is invoked\.  Note that
unless the socket is bound to a pathname with \fBbind()\fR there is no way to receive messages
on this socket\.
.
.P
Example of sending a message to syslogd on OSX via Unix domain socket \fB/var/run/syslog\fR:
.
.IP "" 4
.
.nf
var dgram = require(\'dgram\');
var message = new Buffer("A message to log\.");
var client = dgram\.createSocket("unix_dgram");
client\.send(message, 0, message\.length, "/var/run/syslog",
  function (err, bytes) {
    if (err) {
      throw err;
    }
    console\.log("Wrote " + bytes + " bytes to socket\.");
});
.
.fi
.
.IP "" 0
.
.SS "dgram\.send(buf, offset, length, port, address, [callback])"
For UDP sockets, the destination port and IP address must be specified\.  A string
may be supplied for the \fBaddress\fR parameter, and it will be resolved with DNS\.  An
optional callback may be specified to detect any DNS errors and when \fBbuf\fR may be
re\-used\.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick\.  The only way to know for sure that a send has taken place
is to use the callback\.
.
.P
Example of sending a UDP packet to a random port on \fBlocalhost\fR;
.
.IP "" 4
.
.nf
var dgram = require(\'dgram\');
var message = new Buffer("Some bytes");
var client = dgram\.createSocket("udp4");
client\.send(message, 0, message\.length, 41234, "localhost");
client\.close();
.
.fi
.
.IP "" 0
.
.SS "dgram\.bind(path)"
For Unix domain datagram sockets, start listening for incoming datagrams on a
socket specified by \fBpath\fR\|\. Note that clients may \fBsend()\fR without \fBbind()\fR,
but no datagrams will be received without a \fBbind()\fR\|\.
.
.P
Example of a Unix domain datagram server that echoes back all messages it receives:
.
.IP "" 4
.
.nf
var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var server = dgram\.createSocket("unix_dgram");
server\.on("message", function (msg, rinfo) {
  console\.log("got: " + msg + " from " + rinfo\.address);
  server\.send(msg, 0, msg\.length, rinfo\.address);
});
server\.on("listening", function () {
  console\.log("server listening " + server\.address()\.address);
})
server\.bind(serverPath);
.
.fi
.
.IP "" 0
.
.P
Example of a Unix domain datagram client that talks to this server:
.
.IP "" 4
.
.nf
var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var clientPath = "/tmp/dgram_client_sock";
var message = new Buffer("A message at " + (new Date()));
var client = dgram\.createSocket("unix_dgram");
client\.on("message", function (msg, rinfo) {
  console\.log("got: " + msg + " from " + rinfo\.address);
});
client\.on("listening", function () {
  console\.log("client listening " + client\.address()\.address);
  client\.send(message, 0, message\.length, serverPath);
});
client\.bind(clientPath);
.
.fi
.
.IP "" 0
.
.SS "dgram\.bind(port, [address])"
For UDP sockets, listen for datagrams on a named \fBport\fR and optional \fBaddress\fR\|\.  If \fBaddress\fR is not specified, the OS will try to listen on all addresses\.
.
.P
Example of a UDP server listening on port 41234:
.
.IP "" 4
.
.nf
var dgram = require("dgram");
var server = dgram\.createSocket("udp4");
server\.on("message", function (msg, rinfo) {
  console\.log("server got: " + msg + " from " +
    rinfo\.address + ":" + rinfo\.port);
});
server\.on("listening", function () {
  var address = server\.address();
  console\.log("server listening " +
      address\.address + ":" + address\.port);
});
server\.bind(41234);
// server listening 0\.0\.0\.0:41234
.
.fi
.
.IP "" 0
.
.SS "dgram\.close()"
Close the underlying socket and stop listening for data on it\.  UDP sockets
automatically listen for messages, even if they did not call \fBbind()\fR\|\.
.
.SS "dgram\.address()"
Returns an object containing the address information for a socket\.  For UDP sockets,
this object will contain \fBaddress\fR and \fBport\fR\|\.  For Unix domain sockets, it will contain
only \fBaddress\fR\|\.
.
.SS "dgram\.setBroadcast(flag)"
Sets or clears the \fBSO_BROADCAST\fR socket option\.  When this option is set, UDP packets
may be sent to a local interface\'s broadcast address\.
.
.SS "dgram\.setTTL(ttl)"
Sets the \fBIP_TTL\fR socket option\.  TTL stands for "Time to Live," but in this context it
specifies the number of IP hops that a packet is allowed to go through\.  Each router or
gateway that forwards a packet decrements the TTL\.  If the TTL is decremented to 0 by a
router, it will not be forwarded\.  Changing TTL values is typically done for network
probes or when multicasting\.
.
.P
The argument to \fBsetTTL()\fR is a number of hops between 1 and 255\.  The default on most
systems is 64\.
.
.SS "dgram\.setMulticastTTL(ttl)"
Sets the \fBIP_MULTICAST_TTL\fR socket option\.  TTL stands for "Time to Live," but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic\.  Each router or gateway that forwards a packet
decrements the TTL\. If the TTL is decremented to 0 by a router, it will not be forwarded\.
.
.P
The argument to \fBsetMulticastTTL()\fR is a number of hops between 0 and 255\.  The default on most
systems is 64\.
.
.SS "dgram\.setMulticastLoopback(flag)"
Sets or clears the \fBIP_MULTICAST_LOOP\fR socket option\.  When this option is set, multicast
packets will also be received on the local interface\.
.
.SS "dgram\.addMembership(multicastAddress, [multicastInterface])"
Tells the kernel to join a multicast group with \fBIP_ADD_MEMBERSHIP\fR socket option\.
.
.P
If \fBmulticastInterface\fR is not specified, the OS will try to add membership to all valid
interfaces\.
.
.SS "dgram\.dropMembership(multicastAddress, [multicastInterface])"
Opposite of \fBaddMembership\fR \- tells the kernel to leave a multicast group with \fBIP_DROP_MEMBERSHIP\fR socket option\. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this\.
.
.P
If \fBmulticastInterface\fR is not specified, the OS will try to drop membership to all valid
interfaces\.