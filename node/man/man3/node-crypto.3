.\" Generated with Ronnjs/v0.1
.\" http://github.com/kapouer/ronnjs/
.
.TH "NODE\-CRYPTO" "3" "October 2011" "" ""
.
.SH "NAME"
\fBnode-crypto\fR \-\- http://nodejs\.org/docs/v0\.4\.8/api/crypto\.html
.
.SH "Crypto"
Use \fBrequire(\'crypto\')\fR to access this module\.
.
.P
The crypto module requires OpenSSL to be available on the underlying platform\.
It offers a way of encapsulating secure credentials to be used as part
of a secure HTTPS net or http connection\.
.
.P
It also offers a set of wrappers for OpenSSL\'s hash, hmac, cipher, decipher, sign and verify methods\.
.
.SS "crypto\.createCredentials(details)"
Creates a credentials object, with the optional details being a dictionary with keys:
.
.IP "\(bu" 4
\fBkey\fR : a string holding the PEM encoded private key
.
.IP "\(bu" 4
\fBcert\fR : a string holding the PEM encoded certificate
.
.IP "\(bu" 4
\fBca\fR : either a string or list of strings of PEM encoded CA certificates to trust\.
.
.IP "" 0
.
.P
If no \'ca\' details are given, then node\.js will use the default publicly trusted list of CAs as given in \fIhttp://mxr\.mozilla\.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata\.txt\fR\|\.
.
.SS "crypto\.createHash(algorithm)"
Creates and returns a hash object, a cryptographic hash with the given algorithm
which can be used to generate hash digests\.
.
.P
\fBalgorithm\fR is dependent on the available algorithms supported by the version
of OpenSSL on the platform\. Examples are \fB\'sha1\'\fR, \fB\'md5\'\fR, \fB\'sha256\'\fR, \fB\'sha512\'\fR, etc\.
On recent releases, \fBopenssl list\-message\-digest\-algorithms\fR will display the available digest algorithms\.
.
.P
Example: this program that takes the sha1 sum of a file
.
.IP "" 4
.
.nf
var filename = process\.argv[2];
var crypto = require(\'crypto\');
var fs = require(\'fs\');
var shasum = crypto\.createHash(\'sha1\');
var s = fs\.ReadStream(filename);
s\.on(\'data\', function(d) {
  shasum\.update(d);
});
s\.on(\'end\', function() {
  var d = shasum\.digest(\'hex\');
  console\.log(d + \'  \' + filename);
});
.
.fi
.
.IP "" 0
.
.SS "hash\.update(data)"
Updates the hash content with the given \fBdata\fR\|\.
This can be called many times with new data as it is streamed\.
.
.SS "hash\.digest(encoding=\'binary\')"
Calculates the digest of all of the passed data to be hashed\.
The \fBencoding\fR can be \fB\'hex\'\fR, \fB\'binary\'\fR or \fB\'base64\'\fR\|\.
.
.P
Note: \fBhash\fR object can not be used after \fBdigest()\fR method been called\.
.
.SS "crypto\.createHmac(algorithm, key)"
Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key\.
.
.P
\fBalgorithm\fR is dependent on the available algorithms supported by OpenSSL \- see createHash above\. \fBkey\fR is the hmac key to be used\.
.
.SS "hmac\.update(data)"
Update the hmac content with the given \fBdata\fR\|\.
This can be called many times with new data as it is streamed\.
.
.SS "hmac\.digest(encoding=\'binary\')"
Calculates the digest of all of the passed data to the hmac\.
The \fBencoding\fR can be \fB\'hex\'\fR, \fB\'binary\'\fR or \fB\'base64\'\fR\|\.
.
.P
Note: \fBhmac\fR object can not be used after \fBdigest()\fR method been called\.
.
.SS "crypto\.createCipher(algorithm, password)"
Creates and returns a cipher object, with the given algorithm and password\.
.
.P
\fBalgorithm\fR is dependent on OpenSSL, examples are \fB\'aes192\'\fR, etc\.
On recent releases, \fBopenssl list\-cipher\-algorithms\fR will display the
available cipher algorithms\. \fBpassword\fR is used to derive key and IV, which must be \fB\'binary\'\fR encoded
string (See the Buffers \fIbuffers\.html\fR for more information)\.
.
.SS "crypto\.createCipheriv(algorithm, key, iv)"
Creates and returns a cipher object, with the given algorithm, key and iv\.
.
.P
\fBalgorithm\fR is the same as the \fBcreateCipher()\fR\|\. \fBkey\fR is a raw key used in
algorithm\. \fBiv\fR is an Initialization vector\. \fBkey\fR and \fBiv\fR must be \fB\'binary\'\fR
encoded string (See the Buffers \fIbuffers\.html\fR for more information)\.
.
.SS "cipher\.update(data, input_encoding=\'binary\', output_encoding=\'binary\')"
Updates the cipher with \fBdata\fR, the encoding of which is given in \fBinput_encoding\fR
and can be \fB\'utf8\'\fR, \fB\'ascii\'\fR or \fB\'binary\'\fR\|\. The \fBoutput_encoding\fR specifies
the output format of the enciphered data, and can be \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\|\.
.
.P
Returns the enciphered contents, and can be called many times with new data as it is streamed\.
.
.SS "cipher\.final(output_encoding=\'binary\')"
Returns any remaining enciphered contents, with \fBoutput_encoding\fR being one of: \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\|\.
.
.P
Note: \fBcipher\fR object can not be used after \fBfinal()\fR method been called\.
.
.SS "crypto\.createDecipher(algorithm, password)"
Creates and returns a decipher object, with the given algorithm and key\.
This is the mirror of the \fIcreateCipher()\fR above\.
.
.SS "crypto\.createDecipheriv(algorithm, key, iv)"
Creates and returns a decipher object, with the given algorithm, key and iv\.
This is the mirror of the \fIcreateCipheriv()\fR above\.
.
.SS "decipher\.update(data, input_encoding=\'binary\', output_encoding=\'binary\')"
Updates the decipher with \fBdata\fR, which is encoded in \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\|\.
The \fBoutput_decoding\fR specifies in what format to return the deciphered plaintext: \fB\'binary\'\fR, \fB\'ascii\'\fR or \fB\'utf8\'\fR\|\.
.
.SS "decipher\.final(output_encoding=\'binary\')"
Returns any remaining plaintext which is deciphered,
with \fBoutput_encoding\fR being one of: \fB\'binary\'\fR, \fB\'ascii\'\fR or \fB\'utf8\'\fR\|\.
.
.P
Note: \fBdecipher\fR object can not be used after \fBfinal()\fR method been called\.
.
.SS "crypto\.createSign(algorithm)"
Creates and returns a signing object, with the given algorithm\.
On recent OpenSSL releases, \fBopenssl list\-public\-key\-algorithms\fR will display
the available signing algorithms\. Examples are \fB\'RSA\-SHA256\'\fR\|\.
.
.SS "signer\.update(data)"
Updates the signer object with data\.
This can be called many times with new data as it is streamed\.
.
.SS "signer\.sign(private_key, output_format=\'binary\')"
Calculates the signature on all the updated data passed through the signer\. \fBprivate_key\fR is a string containing the PEM encoded private key for signing\.
.
.P
Returns the signature in \fBoutput_format\fR which can be \fB\'binary\'\fR, \fB\'hex\'\fR or \fB\'base64\'\fR\|\.
.
.P
Note: \fBsigner\fR object can not be used after \fBsign()\fR method been called\.
.
.SS "crypto\.createVerify(algorithm)"
Creates and returns a verification object, with the given algorithm\.
This is the mirror of the signing object above\.
.
.SS "verifier\.update(data)"
Updates the verifier object with data\.
This can be called many times with new data as it is streamed\.
.
.SS "verifier\.verify(object, signature, signature_format=\'binary\')"
Verifies the signed data by using the \fBobject\fR and \fBsignature\fR\|\. \fBobject\fR is  a
string containing a PEM encoded object, which can be one of RSA public key,
DSA public key, or X\.509 certificate\. \fBsignature\fR is the previously calculated
signature for the data, in the \fBsignature_format\fR which can be \fB\'binary\'\fR, \fB\'hex\'\fR or \fB\'base64\'\fR\|\.
.
.P
Returns true or false depending on the validity of the signature for the data and public key\.
.
.P
Note: \fBverifier\fR object can not be used after \fBverify()\fR method been called\.
.
.SS "crypto\.createDiffieHellman(prime_length)"
Creates a Diffie\-Hellman key exchange object and generates a prime of the
given bit length\. The generator used is \fB2\fR\|\.
.
.SS "crypto\.createDiffieHellman(prime, encoding=\'binary\')"
Creates a Diffie\-Hellman key exchange object using the supplied prime\. The
generator used is \fB2\fR\|\. Encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.generateKeys(encoding=\'binary\')"
Generates private and public Diffie\-Hellman key values, and returns the
public key in the specified encoding\. This key should be transferred to the
other party\. Encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.computeSecret(other_public_key, input_encoding=\'binary\', output_encoding=input_encoding)"
Computes the shared secret using \fBother_public_key\fR as the other party\'s
public key and returns the computed shared secret\. Supplied key is
interpreted using specified \fBinput_encoding\fR, and secret is encoded using
specified \fBoutput_encoding\fR\|\. Encodings can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\. If no output encoding is given, the input encoding is used as
output encoding\.
.
.SS "diffieHellman\.getPrime(encoding=\'binary\')"
Returns the Diffie\-Hellman prime in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.getGenerator(encoding=\'binary\')"
Returns the Diffie\-Hellman prime in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.getPublicKey(encoding=\'binary\')"
Returns the Diffie\-Hellman public key in the specified encoding, which can
be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.getPrivateKey(encoding=\'binary\')"
Returns the Diffie\-Hellman private key in the specified encoding, which can
be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.setPublicKey(public_key, encoding=\'binary\')"
Sets the Diffie\-Hellman public key\. Key encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR,
or \fB\'base64\'\fR\|\.
.
.SS "diffieHellman\.setPrivateKey(public_key, encoding=\'binary\')"
Sets the Diffie\-Hellman private key\. Key encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\|\.