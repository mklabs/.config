.\" Generated with Ronnjs/v0.1
.\" http://github.com/kapouer/ronnjs/
.
.TH "NODE\-TLS" "3" "October 2011" "" ""
.
.SH "NAME"
\fBnode-tls\fR \-\- http://nodejs\.org/docs/v0\.4\.8/api/tls\.html
.
.SH "TLS (SSL)"
Use \fBrequire(\'tls\')\fR to access this module\.
.
.P
The \fBtls\fR module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication\.
.
.P
TLS/SSL is a public/private key infrastructure\. Each client and each
server must have a private key\. A private key is created like this
.
.IP "" 4
.
.nf
openssl genrsa \-out ryans\-key\.pem 1024
.
.fi
.
.IP "" 0
.
.P
All severs and some clients need to have a certificate\. Certificates are public
keys signed by a Certificate Authority or self\-signed\. The first step to
getting a certificate is to create a "Certificate Signing Request" (CSR)
file\. This is done with:
.
.IP "" 4
.
.nf
openssl req \-new \-key ryans\-key\.pem \-out ryans\-csr\.pem
.
.fi
.
.IP "" 0
.
.P
To create a self\-signed certificate with the CSR, do this:
.
.IP "" 4
.
.nf
openssl x509 \-req \-in ryans\-csr\.pem \-signkey ryans\-key\.pem \-out ryans\-cert\.pem
.
.fi
.
.IP "" 0
.
.P
Alternatively you can send the CSR to a Certificate Authority for signing\.
.
.P
(TODO: docs on creating a CA, for now interested users should just look at \fBtest/fixtures/keys/Makefile\fR in the Node source code)
.
.SS "s = tls\.connect(port, [host], [options], callback)"
Creates a new client connection to the given \fBport\fR and \fBhost\fR\|\. (If \fBhost\fR
defaults to \fBlocalhost\fR\|\.) \fBoptions\fR should be an object which specifies
.
.IP "\(bu" 4
\fBkey\fR: A string or \fBBuffer\fR containing the private key of the server in
PEM format\. (Required)
.
.IP "\(bu" 4
\fBcert\fR: A string or \fBBuffer\fR containing the certificate key of the server in
PEM format\.
.
.IP "\(bu" 4
\fBca\fR: An array of strings or \fBBuffer\fRs of trusted certificates\. If this is
omitted several well known "root" CAs will be used, like VeriSign\.
These are used to authorize connections\.
.
.IP "" 0
.
.P
\fBtls\.connect()\fR returns a cleartext \fBCryptoStream\fR object\.
.
.P
After the TLS/SSL handshake the \fBcallback\fR is called\. The \fBcallback\fR will be
called no matter if the server\'s certificate was authorized or not\. It is up
to the user to test \fBs\.authorized\fR to see if the server certificate was
signed by one of the specified CAs\. If \fBs\.authorized === false\fR then the error
can be found in \fBs\.authorizationError\fR\|\.
.
.SS "STARTTLS"
In the v0\.4 branch no function exists for starting a TLS session on an
already existing TCP connection\.  This is possible it just requires a bit of
work\. The technique is to use \fBtls\.createSecurePair()\fR which returns two
streams: an encrypted stream and a plaintext stream\. The encrypted stream is then
piped to the socket, the plaintext stream is what the user interacts with thereafter\.
.
.P
Here is some code that does it\. \fIhttp://gist\.github\.com/848444\fR
.
.SS "tls\.Server"
This class is a subclass of \fBnet\.Server\fR and has the same methods on it\.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL\.
.
.P
Here is a simple example echo server:
.
.IP "" 4
.
.nf
var tls = require(\'tls\');
var fs = require(\'fs\');
var options = {
  key: fs\.readFileSync(\'server\-key\.pem\'),
  cert: fs\.readFileSync(\'server\-cert\.pem\')
};
tls\.createServer(options, function (s) {
  s\.write("welcome!\\n");
  s\.pipe(s);
})\.listen(8000);
.
.fi
.
.IP "" 0
.
.P
You can test this server by connecting to it with \fBopenssl s_client\fR:
.
.IP "" 4
.
.nf
openssl s_client \-connect 127\.0\.0\.1:8000
.
.fi
.
.IP "" 0
.
.TP
tls\.createServer(options, secureConnectionListener)
.This is a constructor for the \fBtls\.Server\fR class\. The options object
has these possibilities:
.
.IP "\(bu" 4
\fBkey\fR: A string or \fBBuffer\fR containing the private key of the server in
PEM format\. (Required)
.
.IP "\(bu" 4
\fBcert\fR: A string or \fBBuffer\fR containing the certificate key of the server in
PEM format\. (Required)
.
.IP "\(bu" 4
\fBca\fR: An array of strings or \fBBuffer\fRs of trusted certificates\. If this is
omitted several well known "root" CAs will be used, like VeriSign\.
These are used to authorize connections\.
.
.IP "\(bu" 4
\fBrequestCert\fR: If \fBtrue\fR the server will request a certificate from
clients that connect and attempt to verify that certificate\. Default: \fBfalse\fR\|\.
.
.IP "\(bu" 4
\fBrejectUnauthorized\fR: If \fBtrue\fR the server will reject any connection
which is not authorized with the list of supplied CAs\. This option only
has an effect if \fBrequestCert\fR is \fBtrue\fR\|\. Default: \fBfalse\fR\|\.
.
.IP "" 0
.
.TP
Event: \'secureConnection\'
.\fBfunction (cleartextStream) {}\fR
.
.P
This event is emitted after a new connection has been successfully
handshaked\. The argument is a duplex instance of \fBstream\.Stream\fR\|\. It has all
the common stream methods and events\.
.
.P
\fBcleartextStream\.authorized\fR is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server\. If \fBcleartextStream\.authorized\fR is false, then \fBcleartextStream\.authorizationError\fR is set to describe how authorization
failed\. Implied but worth mentioning: depending on the settings of the TLS
server, unauthorized connections may be accepted\.
.
.TP
server\.listen(port, [host], [callback])
.Begin accepting connections on the specified \fBport\fR and \fBhost\fR\|\.  If the \fBhost\fR is omitted, the server will accept connections directed to any
IPv4 address (\fBINADDR_ANY\fR)\.
.
.P
This function is asynchronous\. The last parameter \fBcallback\fR will be called
when the server has been bound\.
.
.P
See \fBnet\.Server\fR for more information\.
.
.TP
server\.close()
.Stops the server from accepting new connections\. This function is
asynchronous, the server is finally closed when the server emits a \fB\'close\'\fR
event\.
.
.TP
server\.maxConnections
.Set this property to reject connections when the server\'s connection count gets high\.
.
.TP
server\.connections
.The number of concurrent connections on the server\.